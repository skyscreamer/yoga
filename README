Inspired by LinkedIn’s JavaOne presentation on building flexible REST interfaces (http://blog.linkedin.com/2009/07/08/brandon-duncan-java-one-building-consistent-restful-apis-in-a-high-performance-environment/), Yoga is a framework for supporting REST-like URI requests with field selectors.  This is based on half a year of R&D and discussions with people in the REST community.

Here's the problem we’re trying to solve. I want to get the birthdays for everyone on my softball team from the league web site's nifty REST interface.  In REST, I would do something like this:

GET /teams/4234.json
{ name: "Artful Dodgers", location: "Brooklyn, NY", members: [ { id: 123, name: "Joe Torre", href: "/users/123.json" }, { id: 234, name "Jose Canseco", href: "/users/234.json" }, { id: 345, name: "Jackie Robinson", href: "/users/345.json" } ] }

Then I perform a detailed get for each member:
GET /users/123.json
GET /users/234.json
GET /users/345.json

Which would return the full data set for the user. The full data set may include some fields (we’ll call them expensive fields) which are not needed by all clients but require server computing resources to generate.

Common data access approaches in REST APIs include:

1) Make 11 calls, as described above. Expensive fields are always returned, even if not needed by the client. Usually awful performance for mobile clients on wireless connections.

2) Return the kitchen sink with each call (a la Twitter, eg: http://apiwiki.twitter.com/w/page/22554714/Twitter-REST-API-Method:-GET-list-members). Expensive fields are always returned, even if not needed by the client. This approach does not scale, as the size and complexity of the response, and the server computing resources needed to handle the request, quickly balloon.

3) Severely restrict the functionality of the API to avoid any of these problems. A surprisingly common approach in public REST API’s.

We have decided to support a field selector approach where the URI’s look like this:

GET /teams/4234.json?selector=:(members:(id,name,birthday)
{ name: "Artful Dodgers", location: "Brooklyn, NY", members: [ { id: 123, name: "Joe Torre", birthday: "01/02/34" }, { id: 234, name "Jose Canseco", birthday: "02/03/45"}, { id: 345, name: "Jackie Robinson", birthday: "03/04/54"} ] }

Clean footprint, dataset is tight, and it's a single call. Expensive fields are only returned if required by the client.

After giving client developers complete freedom with the selectors in a test or sandbox environment, we intend to provide the capabilities to "lock down" these queries for production.  This provides some control over what is hitting the production systems, and looks a lot better.  For example, the last query above could be aliased to:

GET /teams/memberBirthdays/4234.json

The important thing is once defining the initial REST types, there is no server-side programming required to change the client queries, or even to enable/disable the RESTful aliases that are published in production.

